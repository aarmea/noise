package com.alternativeinfrastructures.noise.storage

import android.os.Looper
import android.util.Log

import com.alternativeinfrastructures.noise.NoiseDatabase
import com.raizlabs.android.dbflow.annotation.ForeignKey
import com.raizlabs.android.dbflow.annotation.ForeignKeyAction
import com.raizlabs.android.dbflow.annotation.PrimaryKey
import com.raizlabs.android.dbflow.annotation.Table
import com.raizlabs.android.dbflow.rx2.language.RXSQLite
import com.raizlabs.android.dbflow.rx2.structure.BaseRXModel
import com.raizlabs.android.dbflow.sql.language.CursorResult
import com.raizlabs.android.dbflow.sql.language.Method
import com.raizlabs.android.dbflow.sql.language.SQLite
import com.raizlabs.android.dbflow.structure.database.DatabaseWrapper

import java.util.ArrayList
import java.util.BitSet
import java.util.Vector

import io.reactivex.Flowable
import io.reactivex.Single
import util.hash.MurmurHash3

// Actual bloom filter implementation based heavily on this guide:
// http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/
@Table(database = NoiseDatabase::class)
class BloomFilter internal constructor() : BaseRXModel() {

    @PrimaryKey
    @ForeignKey(onDelete = ForeignKeyAction.CASCADE, stubbedRelationship = true)
    protected var message: UnknownMessage? = null

    @PrimaryKey
    protected var hash: Int = 0

    companion object {
        val TAG = "BloomFilter"

        // TODO: Tune these
        // They need to be large enough to describe billions of messages
        // but also small enough to transmit in a few seconds over Bluetooth
        internal val SIZE = 1 shl 20 // in bits
        internal val USABLE_SIZE = SIZE - 1
        internal val NUM_HASHES = 5

        val SIZE_IN_BYTES = SIZE / 8

        internal fun hashMessage(message: UnknownMessage): List<Int> {
            val hashList = Vector<Int>(NUM_HASHES)

            // TODO: Is using a non-cryptographic hash like murmurhash okay? An attacker can generate messages that match the hashes to try to block it
            val primaryHash = MurmurHash3.LongPair()
            MurmurHash3.murmurhash3_x64_128(message.payload.blob, 0 /*offset*/, UnknownMessage.PAYLOAD_SIZE, 0 /*seed*/, primaryHash)
            for (hashFunction in 0 until NUM_HASHES)
                hashList.add(nthHash(primaryHash.val1, primaryHash.val2, hashFunction).toInt())

            return hashList
        }

        internal fun addMessage(message: UnknownMessage, databaseWrapper: DatabaseWrapper) {
            if (Looper.getMainLooper() == Looper.myLooper())
                Log.e(TAG, "Attempting to save on the UI thread")

            for (hash in hashMessage(message)) {
                val row = BloomFilter()
                row.message = message
                row.hash = hash
                // blockingGet is okay here because this is always called from within a Transaction
                row.save(databaseWrapper).blockingGet()
            }
        }

        fun makeEmptyMessageVector(): BitSet {
            val messageVector = BitSet(SIZE)
            messageVector.set(USABLE_SIZE) // Hack to keep the generated byte array the same size
            return messageVector
        }

        val messageVectorAsync: Single<BitSet>
            get() = RXSQLite.rx(SQLite.select(BloomFilter_Table.hash.distinct()).from(BloomFilter::class.java))
                    .queryResults().map { bloomCursor: CursorResult<BloomFilter> ->
                        val messageVector = makeEmptyMessageVector()
                        for (bloomIndex in 0 until bloomCursor.count) {
                            val filterElement = bloomCursor.getItem(bloomIndex)
                            if (filterElement != null)
                                messageVector.set(filterElement.hash)
                        }
                        bloomCursor.close()
                        messageVector
                    }

        fun getMatchingMessages(messageVector: BitSet): Flowable<UnknownMessage> {
            val hashes = ArrayList<Int>(messageVector.cardinality())
            run {
                var hash = messageVector.nextSetBit(0)
                while (hash != -1) {
                    hashes.add(hash)
                    hash = messageVector.nextSetBit(hash + 1)
                }
            }

            // TODO: Implement Noise message priority - order by date and zero bits
            return RXSQLite.rx(SQLite.select(*UnknownMessage_Table.ALL_COLUMN_PROPERTIES)
                    .from(UnknownMessage::class.java).leftOuterJoin(BloomFilter::class.java)
                    .on(UnknownMessage_Table.id.eq(BloomFilter_Table.message_id))
                    .where(BloomFilter_Table.hash.`in`(hashes))
                    .groupBy(BloomFilter_Table.message_id)
                    .having(Method.count().eq(NUM_HASHES)))
                    .queryStreamResults()
        }

        private fun nthHash(hashA: Long, hashB: Long, hashFunction: Int): Long {
            // Double modulus ensures that the result is positive when any of the hashes are negative
            return ((hashA + hashFunction * hashB) % USABLE_SIZE + USABLE_SIZE) % USABLE_SIZE
        }
    }
}
